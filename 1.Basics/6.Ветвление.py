'''
Оператор ветвления применяется в случаях,
когда выполнение набора команд должно зависеть от выполнения некоторого условия.
Это позволяет направлять действия программы по определенному пути.
Реализовать условия в python позволяет конструкция - if. Она имеет следующее определение:
if условие_1:
    инструкции
    elif условие_2:
    инструкции
    else:
    инструкции
Блок else выполняется только в том случае, если не одно из условий не было выполнено.
Если условие верно для нескольких блоков, то выполняется только первое.
'''

num1 = 5
num2 = 10

if num1 > 2:
    print("num1 больше 2")
elif num1 > 3:
    print("num1 больше 3")
else:
    print("нет подходящих условий")
''' 
В данном примере будет выведено в консоль "num1 больше 2", так как 5 больше 2,
и это первое верное условие! Второе условие в нашей программе не может быть выполнено.
Если мы переопредели значение i = 1, то все условия будут ошибочны, и будет выведен блок else,
либо при его отсутствии, программа продолжит выполняться дальше.
'''
'''
Множественные условия
- and (и) подразумевает, что оба условия должны быть верны,
тогда все выражение верно. Если хоть одно не верно, то все выражение ошибочно.
- or (или) подразумевает, что хотя бы одно из условий должно быть верно,
тогда все выражение считается верным.
'''

if num1 == 1 and (num2 == 2 or num2 == 5):
    print("block if", num1, num2)

elif num1 == 3 and num2 == 4:
    print("block elif", num1, num2)

else:
    print("block else")

# Запись условия в 1 строку.
print("Верно!") if (num1 < num2) else print("Не верно!")

# Данная запись аналогична
if num1 < num2:
    print("Верно!")
else:
    print("Не верно!")

# Проверка на наличие в списке
# если i ЕСТЬ в списке
i = "y"
if i in ["y", "Y"]:
    print('Верно! {} in ["y", "Y"]'.format(i))
# если i НЕТ в списке
if i not in ["n", "N"]:
    print('ОШИБКА! {} NOT ["n", "N"]'.format(i))

# проверяет есть ли x и присваивает его python 3.8
p = {"foo": "bar"}
if x := p.get("foo"):
    print(x)


# Альтернатива множественным if - else
def fun1(a):
    print("msg" + a)


def fun2():
    print("msg2")


method = {
    "test": fun1,
    "fun2": fun2,
}
# В первом случае будет вызвана функции соответствующая ключу test
# с аргументом _ttt_
# Во стором будет вызвана функция fun2
method["test"]("_ttt_")
method["fun2"]()
