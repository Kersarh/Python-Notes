'''
Регулярные выражения

.	Один любой символ, кроме новой строки \n.
?	0 или 1 вхождение шаблона слева
+	1 и более вхождений шаблона слева
*	0 и более вхождений шаблона слева
\w	Любая цифра или буква
\W	Все, кроме буквы или цифры
\d	Любая цифра [0-9]
\D	Все, кроме цифры
\s	Любой пробельный символ
\s	Любой НЕ пробельный символ)
\b	Граница слова
[..]	Один из символов в скобках
[^..]	Любой символ, кроме тех, что в скобках
\	Экранирование специальных символов
\.	Означает точку или \+ знак «плюс»)
^ и $	Начало и конец строки соответственно
{n,m}	От n до m вхождений ({,m} — от 0 до m)
a|b	Соответствует a или b
()	Группирует выражение и возвращает найденный текст
\t, \n, \r	Символ табуляции, новой строки и возврата каретки соответственно
'''

import re

# Зададим регулярное выражение [a-z]+
p = re.compile("[a-z]+")
'''
match()	Ищет в начале строки.
search()	Сканировать ВСЮ строку
	в поисках всех совпадений с регулярным выражением.
findall()	Найти все подстроки совпадений с регулярным выражением
	и вернуть их в виде СПИСКА
finditer()	Найти все подстроки совпадений с регулярным выражением и вернуть их в виде ИТЕРАТОРА
'''
print("-- match --")
m = p.match("temp11111test")
print("match -", m)
'''
методы math
group() 	Вернуть строку, сошедшуюся с регулярным выражением
start() 	Вернуть позицию начала совпадения
end() 	Вернуть позицию конца совпадения
span() 	Вернуть кортеж (start, end) позиций совпадения
'''

if m is not None:  # если в m что-то есть то вывести на экран
    print("group >>", m.group())
    # Индекс первого и последнего символа
    print("start-end >>", m.start(), m.end())
    print("span >>", m.span())
else:
    print("no_data")

print("-- search --")
m = p.search("1111test34343testsdf")
print(m)
print(m.group())
print(m.span())

print("-- FINDALL --")
m = p.findall("1111test222user333")
print(m)

print("-- finditer --")
iterator = p.finditer("1111test222user333")
print(iterator)
for i in iterator:
    print(i.span())

print("----- Флаги компиляции -----")
p = re.compile("From\w+", re.IGNORECASE)
print(p.findall("Fromage amk fROMsdf sdfsd"))
# ИЛИ
print(re.findall(r"From\w+", "Fromage amk fROMsdf sdfsd", re.VERBOSE))
'''
IGNORECASE, I - Не различать заглавные и строчные буквы.

DOTALL, S - Указывает "." сопоставить любой символ.
Без этого флага будет сопоставлять все но не новую строку.

LOCALE, L - Делает \w, \W, \b, \B зависящими от локализации.

MULTILINE, M - Специальные символы ^ и $ соответствуют началу и концу каждой строки

UNICODE, U - Делает \w, \W, \b, \B, \d, \D, \s, \S соответствующими таблице Unicode.

VERBOSE, X - Пустое пространство внутри паттерна будет игнорироваться.
Позволяет визуально разделять логические секции регулярных выражений,
и даже добавлять комментарии #.
Кроме случая если символу или пробелу предшествует обратная косая черта.

DEBUG - Показывает информацию о дебаге вашего скомпилированного выражения
'''
