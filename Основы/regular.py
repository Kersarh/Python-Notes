# -*- coding: UTF-8 -*-

import os
import re

# [a-z]+ = регулярное выражение
p = re.compile('[a-z]+')

# match() 	Определить, начинается ли совпадение регулярного выражения с начала строки
# search() 	Сканировать всю строку в поисках всех мест совпадений с регулярным выражением
# findall() 	Найти все подстроки совпадений с регулярным выражением и вернуть их в виде списка
# finditer() Найти все подстроки совпадений с регулярным выражением и вернуть их в виде итератора

print("-- MATH --")

m = p.match("temp11111")
print(m)

# методы math
# group() 	Вернуть строку, сошедшуюся с регулярным выражением
# start() 	Вернуть позицию начала совпадения
# end() 	Вернуть позицию конца совпадения
# span() 	Вернуть кортеж (start, end) позиций совпадения

if m != None:  # если в m что-то есть то вывести на экран
	print(m.group())
	print(m.start(), m.end())
	print(m.span())
else:
	print("no_data")

print("-- SEARCH --")

m = p.search('1111test34343testsdf')
print(m)
print(m.group())
print(m.span())

print("-- FINDALL --")
m = p.findall('1111test222user333')
print(m)

print("-- FINDITER --")
iterator = p.finditer('1111test222user333')
print(iterator)
for i in iterator:
	print(i.span())

# Функции на уровне модуля + Флаги компиляции
#DOTALL, S
# Сопоставление, такое же как '.', то есть с любым символом,
# но при включении этого флага, в рассмотрение добавляется и символ новой строки.

#IGNORECASE, I
# Сопоставление без учета регистра; Например, [A-Z] будет также соответствовать и строчным буквам,
# так что Spam будет соответствовать Spam, spam, spAM и так далее.

#LOCALE, L
# Делает \w, \W, \b, \B зависящими от локализации.
# Например, если вы работаете с текстом на французском, и хотите написать
#\w+ для того, чтобы находить слова, но \w ищет только символы из множества [A-Za-z]
# и не будет искать 'é' или 'ç'. Если система настроена правильно и выбран французский язык, 'é' также будет рассматриваться как буква.

#MULTILINE, M
# Обычно ^ ищет соответствие только в начале строки,
# а $ только в конце непосредственно перед символом новой строки (если таковые имеются).
# Если этот флаг указан, ^ сравнение происходит во всех строках, то есть и в начале,
# и сразу же после каждого символа новой строки. Аналогично для $.

#UNICODE, U
# Делает \w, \W, \b, \B, \d, \D, \s, \S соответствующими таблице Unicode.

#VERBOSE, X
# Включает многословные (подробные) регулярные выражения,
# которые могут быть организованы более ясно и понятно.
# Если указан этот флаг, пробелы в строке регулярного выражения игнорируется,
# кроме случаев, когда они имеются в классе символов или им предшествует неэкранированный бэкслеш;
# это позволяет вам организовать регулярные выражения более ясным образом.
# Этот флаг также позволяет помещать в регулярные выражения комментарии, начинающиеся с '#',
# которые будут игнорироваться движком.

print(re.findall(r"From\w+", "Fromage amk fROMsdf sdfsd", re.IGNORECASE))

os.system('pause' if os.name == 'nt' else
          """bash -c 'read -s -n 1 -p "Press any key to continue...\n"'""")
